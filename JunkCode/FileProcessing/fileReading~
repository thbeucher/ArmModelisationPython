#################################################
######### Permet de récupérer xminmax ##########
###############################################
    def getxMinMax(self, nbfeat):
        folder = getcwd()
        folder = op.split(folder)
        folder = folder[0] + "/FileProcessing/RegressionResults/"
        folderNbFeat = folder + str(nbfeat) + "_feats/xMinMax"
        with open(folderNbFeat, "rb") as file:
            mondepickler = pickle.Unpickler(file)
            data = mondepickler.load()
        return data


#####################################################################################
Fonction pour mettre dans tes tableaux separes les differentes activations musculaires                      
#####################################################################################
    def tabActivationMuscu(self, nameFileTemp, commandAll = None, a = False):
        #Recuperation dans des tableaux des activations musculaires
        j = 0
        u1 = []
        u2 = []
        u3 = []
        u4 = []
        u5 = []
        u6 = []
        if a == True:    
            for el in commandAll:
                u1.append(el[0])
                u2.append(el[1])
                u3.append(el[2])
                u4.append(el[3])
                u5.append(el[4])
                u6.append(el[5])
        else:
            while j < len(self.data_store[str(nameFileTemp + "_command")]):
                u1.append(((self.data_store[str(nameFileTemp + "_command")])[j])[0])
                u2.append(((self.data_store[str(nameFileTemp + "_command")])[j])[1])
                u3.append(((self.data_store[str(nameFileTemp + "_command")])[j])[2])
                u4.append(((self.data_store[str(nameFileTemp + "_command")])[j])[3])
                u5.append(((self.data_store[str(nameFileTemp + "_command")])[j])[4])
                u6.append(((self.data_store[str(nameFileTemp + "_command")])[j])[5])
                j += 1
        #Rangement dans un dictionnaire des differents tableaux d'activations musculaires
        self.uCommand[str(nameFileTemp + "_u1")] = u1
        self.uCommand[str(nameFileTemp + "_u2")] = u2
        self.uCommand[str(nameFileTemp + "_u3")] = u3
        self.uCommand[str(nameFileTemp + "_u4")] = u4
        self.uCommand[str(nameFileTemp + "_u5")] = u5
        self.uCommand[str(nameFileTemp + "_u6")] = u6
    '''data_store = {}   
    data_store, nameFichier, nbFichier = recup_data()
    print(len(data_store))
    print(len(data_store[str(nameFichier + "1_state")]))
    print(len(data_store[str(nameFichier + "1_command")]))'''




    '''coord = [(-0.2,0.39)]
    coord.append((-0.1,0.39))
    coord.append((0.,0.39))
    coord.append((0.1,0.39))
    coord.append((0.2,0.39))
    coord.append((-0.3,0.0325))
    coord.append((-0.2,0.0325))
    coord.append((-0.1,0.0325))
    coord.append((0.,0.0325))
    coord.append((0.1,0.0325))
    coord.append((0.2,0.0325))
    coord.append((0.3,0.0325))
    coord.append((0.,0.6175))
    
    f = lambda col: col[0]
    g = lambda col: col[1]
    print(f(coord[0]))
    
    angle = []
    robot = pr.ParametresRobot()
    for el in coord:
        q1, q2 = convertToAngle(el[0], el[1], robot)
        angle.append((q1,q2))
    print(angle)
    
    monfichier = open("q1q2pourChaqueXhYh","w")
    i = 0
    for el1 in coord:
        monfichier.write(str(i+1) + "-Coordonnees: (xh=" + str(el1[0]) + ",yh=" + str(el1[1]) + ") et angle du bras associés: (p1=" + str(f(angle[i])) + ",p2=" + str(g(angle[i])) + ")\n")
        i += 1
    monfichier.close()
    
    monFichierAjout = open("q1q2pourChaqueXhYh","a")
    for el in angle:
        monFichierAjout.write("{" + str(el[0]) + "," + str(el[1]) + "},")
    monFichierAjout.close()
    
    print(ma.atan2(2, 1))'''




######################################################
 Permet de récupérer les theta de lwr 
#####################################################
    def getTheta(self, nbfeat, choix):
        folder = getcwd()
        folder = op.split(folder)
        folder = folder[0] + "/FileProcessing/RegressionResults/"
        if choix == 0:
            folder = folder + str(nbfeat) + "_feats/AllCommand_u"
        else:
            folder = folder + str(nbfeat) + "_feats/trajectoire" + str(choix) + "_u"
        for i in range(6):
            name = folder + str(i+1)
            with open(name, "rb") as file:
                mondepickler = pickle.Unpickler(file)
                data = mondepickler.load()
            self.theta_store[str("u" + str(i+1))] = data



def convertToAngle(self, xh, yh, robot):
        if (xh**2+yh**2-robot.l1**2-robot.l2**2)/(2*robot.l1*robot.l2) < -1:
            q2 = np.arccos(1)
        else:
            q2 = np.arccos((xh**2+yh**2-robot.l1**2-robot.l2**2)/(2*robot.l1*robot.l2))
        q1 = ma.atan2(yh, xh)-ma.atan2(robot.l2*np.sin(q2), robot.l1 + robot.l2*np.cos(q2))
        return q1, q2






#code test xy vers q12 puis re vers xy
'''fr = FileReading()
robot = ParametresRobot()
save = SavingData()
x = np.arange(-0.65,0.65,0.05)
y = np.arange(-0.65,0.65,0.05)
X,Y = np.meshgrid(x,y)

plt.figure()
plt.scatter(X,Y,c='b')

p = fr.convertToAngle(X[5,5], Y[5,5], robot)
print(X[5,5], Y[5,5], "\n", p[0], p[1], "\n", save.calculCoord(np.mat([[p[0]],[p[1]]]), robot))
q = []
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        q.append(fr.convertToAngle(X[i,j], Y[i,j], robot))
cor = []
for el in q:
    if not isnan(el[0]) or not isnan(el[1]):
        corE, corH = save.calculCoord(np.mat([[el[0]],[el[1]]]), robot)
        cor.append(corH)
    elif isnan(el[0]) or isnan(el[1]):
        cor.append(("nan", "nan"))

corx = []
cory = []
for el in cor:
    corx.append(el[0])
    cory.append(el[1])
plt.figure()
plt.scatter(corx, cory, c='r')        

maxminmoy = []
with open("testUnitaireConvertToAngle", "w+") as file:
    co = 0
    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            if not isnan(q[j+co][0]):
                a = tronquerNB(X[i,j], 3)
                b = tronquerNB(Y[i,j], 3)
                c = tronquerNB(q[j+co][0], 3)
                d = tronquerNB(q[j+co][1], 3)
                e = tronquerNB(cor[j+co][0], 3)
                f = tronquerNB(cor[j+co][1], 3)
                g = tronquerNB(abs(e-a), 3)
                h = tronquerNB(abs(f-b), 3)
                maxminmoy.append((g,h))
                file.write(str("xy:("+str(a)+","+str(b)+")    q1,q2:("+str(c)+","+str(d)+")    x'y':("+str(e)+","+str(f)+")    err xy:("+str(g)+","+str(h) +")\n"))
        co += X.shape[1]
print("max:", np.max(np.array(maxminmoy)), "min:", np.min(np.array(maxminmoy)), "moy:", np.mean(np.array(maxminmoy)))

plt.show()'''


'''fr = FileReading()
fr.recup_pos_ini()
robot = ParametresRobot()
q = []
rec = []
save = SavingData()
#Bout de code pour generer les q1, q2 associes aux positions initiales
a = [(-0.2,0.39),(-0.1,0.39),(0.0,0.39),(0.1,0.39),(0.2,0.39),(-0.3,0.26),(-0.2,0.26),(-0.1,0.26),(0.0,0.26),(0.1,0.26),(0.2,0.26),(0.3,0.26)]
for el in a:
    q.append(fr.convertToAngle(el[0], el[1], robot))
fileSavingStr("coucouPOS", q)
for el in q:
    coorE, coorH = save.calculCoord(np.mat([[el[0]], [el[1]]]), robot)
    rec.append(coorH)
fileSavingStr("coucouRECOR", rec)'''

'''x = np.arange(-0.5,0.5,0.025)
y = np.arange(0.1,0.6,0.025)
X, Y = np.meshgrid(x,y)
print(x.shape, y.shape, X.shape, Y.shape)
q = []
fr = FileReading()
robot = ParametresRobot()
for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        a,b = fr.convertToAngle(X[i,j], Y[i,j], robot)
        if np.isnan(a) or np.isnan(b):
            pass
        else:
            q.append((a, b))
print(len(q), np.max(q, axis = 0), np.min(q, axis = 0), "\n", q)
with open("q1q2747", "w+") as file:
    for el in q:
        file.write(str("{" + str(el[0]) + "," + str(el[1]) + "},"))'''

'''q = []
fr = FileReading()
robot = ParametresRobot()
for el in a:
    q.append(fr.convertToAngleTest(el[0], el[1], robot))
fileSavingStr("q1q2ForPosIniAlea", q)'''
        
        
#Code test q12 vers xy puis re vers q12
'''fr = FileReading()
robot = ParametresRobot()
save = SavingData()
q1 = np.arange(-0.6,2.6,0.05)
q2 = np.arange(-0.2,3.0,0.05)
Q1,Q2 = np.meshgrid(q1,q2)
coor = []
for i in range(Q1.shape[0]):
    for j in range(Q1.shape[1]):
        coorE, coorH = save.calculCoord(np.mat([[Q1[i,j]],[Q2[i,j]]]), robot)
        coor.append((coorH[0], coorH[1]))
q12b = []
for el in coor:
    q12b.append(fr.convertToAngle(el[0], el[1], robot))
maxminmoy = []
with open("testUnitaireCalculCoord", "w+") as file:
    co = 0
    for i in range(Q1.shape[0]):
        for j in range(Q1.shape[1]):
            if not isnan(q12b[j+co][0]):
                a = tronquerNB(Q1[i,j], 3)
                b = tronquerNB(Q2[i,j], 3)
                c = tronquerNB(coor[j+co][0], 3)
                d = tronquerNB(coor[j+co][1], 3)
                e = tronquerNB(q12b[j+co][0], 3)
                f = tronquerNB(q12b[j+co][1], 3)
                g = tronquerNB(abs(e-a), 3)
                h = tronquerNB(abs(f-b), 3)
                maxminmoy.append((g,h))
                file.write(str("q1q2:("+str(a)+","+str(b)+")    xy:("+str(c)+","+str(d)+")    q1'q2':("+str(e)+","+str(f)+")    err q1q2:("+str(g)+","+str(h) +")\n"))
        co += Q1.shape[1]
print("max:", np.max(np.array(maxminmoy)), "min:", np.min(np.array(maxminmoy)), "moy:", np.mean(np.array(maxminmoy)))'''


#Test unitaire de la fonction mgi
'''fr = FileReading()
save = SavingData()
robot = ParametresRobot()

x = np.arange(-0.6,0.6,0.05)
y = np.arange(-0.6,0.6,0.05)
X,Y = np.meshgrid(x,y)
plt.figure()
plt.scatter(X,Y,c='b')

q = []
for i in range(X.shape[0]):
    for j in range(Y.shape[1]):
        q.append(fr.mgi(X[i,j], Y[i,j], robot))

cor = []
for el in q:
    if el != "None":
        corE, corH = save.calculCoord(np.mat([[el[0]],[el[1]]]), robot)
        cor.append(corH)
corx, cory = [], []
for el in cor:
    corx.append(el[0])
    cory.append(el[1])
plt.figure()
plt.scatter(corx, cory, c='r')

plt.show()'''






