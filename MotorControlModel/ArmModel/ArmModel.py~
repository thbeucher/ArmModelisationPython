#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author: Thomas Beucher

Module: ArmModels

Description:    
-Models an arm with two joints and six muscles
-Computes its dynamics
'''

import numpy as np
import math
from Utils.StateVectorUtil import createStateVector, getDotQAndQFromStateVectorS

class ArmModels:
    
    def __init__(self):
        self.__dotq0 = np.array([[0.],[0.]])
        
    def initStateAD(self, state):
        self.state = state
        
    def initParametersAD(self, armP, musclesP, dt):
        self.armP = armP
        self.musclesP = musclesP
        self.dt = dt
        
    def setNewStateAD(self, dotq, q):
        self.state = createStateVector(dotq, q)
        
    def computeMCQ(self, state):
        '''
        Sets M, C, Minv, Q to compute the dynamic equation of the arm
        
        Inputs:     -state: (4,1) numpy array
                    -dotq: (2,1) numpy array
                    -q: (2,1) numpy array

        Output:    -Minv: inverse inertia matrix, numpy array
                    -C: coriolis force vector, numpy array
                    -Q: torque term, numpy array
        '''
        dotq, q = getDotQAndQFromStateVectorS(state)
        M = np.array([[self.armP.k1+2*self.armP.k2*math.cos(q[1,0]),self.armP.k3+self.armP.k2*math.cos(q[1,0])],[self.armP.k3+self.armP.k2*math.cos(q[1,0]),self.armP.k3]])
        C = np.array([[-dotq[1,0]*(2*dotq[0,0]+dotq[1,0])*self.armP.k2*math.sin(q[1,0])],[(dotq[0,0]**2)*self.armP.k2*math.sin(q[1,0])]])
        Minv = np.linalg.inv(M)
        Q = np.diag([q[0,0], q[0,0], q[1,0], q[1,0], q[0,0], q[0,0]])
        return Minv, C, Q, dotq, q
        
    def mddAD(self, U):
        '''
        Computes the next state resulting from the direct dynamic model of the arm given the muscles activation vector U
        
        Inputs:     -U: (6,1) numpy array

        Output:    -state: (4,1) numpy array
        '''
        Minv, C, Q = self.computeMCQ(self.state)
        #the commented version uses a non null stiffness for the muscles
        #Gamma = np.dot((np.dot(armP.At, musclesP.fmax)-np.dot(musclesP.Kraid, Q)), U)
        Gamma = np.dot((np.dot(self.armP.At, self.musclesP.fmax)-np.dot(self.musclesP.Knulle, Q)), U)
        #Gamma = np.dot(armP.At, np.dot(musclesP.fmax,U))
        #computes the acceleration ddotq and integrates
        dotq, q = getDotQAndQFromStateVectorS(self.state)
        ddotq = np.dot(Minv,(Gamma - C - np.dot(self.armP.B, dotq)))
        dotq += ddotq*self.dt
        q += dotq*self.dt
        #save the real state to compute the state at the next step with the real previous state
        self.setNewStateAD(dotq, q)
        return self.state
    
    def mddADUKF(self, U, state):
        '''
        Computes the next state for the kalman filter
        
        Inputs:     -U: (6,1) numpy array
                    -state: (4,1) numpy array

        Output:    -nextState: (4,1) numpy array
        '''
        Minv, C, Q, dotq, q = self.computeMCQ(state)
        Gamma = np.dot((np.dot(self.armP.At, self.musclesP.fmax)-np.dot(self.musclesP.Knulle, Q)), U)
        ddotq = np.dot(Minv,(Gamma - C - np.dot(self.armP.B, dotq)))
        dotq += ddotq*self.dt
        q += dotq*self.dt
        nextState = createStateVector(dotq, q)
        return nextState

    def get_dotq_0(self):
        return np.array(self.__dotq0)

    def set_dotq_0(self, value):
        self.__dotq0 = value

    def del_dotq_0(self):
        del self.__dotq0

    dotq0 = property(get_dotq_0, set_dotq_0, del_dotq_0, "dotq0's docstring")
    
def mdd(q, dotq, U, dt):
    '''
    Computes the acceleration and next state resulting from the direct dynamic model of the arm given the arm state (q,dotq), 
    the muscles activation vector U and the time step dt.
    
    Inputs:     -q: (2,1) numpy array
                -dotq: (2,1) numpy array
                -U: (6,1) numpy array
    Output:    -ddotq: (2,1) numpy array
    '''
    #Inertia matrix
    M = np.array([[self.armP.k1+2*self.armP.k2*math.cos(q[1,0]),self.armP.k3+self.armP.k2*math.cos(q[1,0])],[self.armP.k3+self.armP.k2*math.cos(q[1,0]),self.armP.k3]])
    #Coriolis force vector
    C = np.array([[-dotq[1,0]*(2*dotq[0,0]+dotq[1,0])*self.armP.k2*math.sin(q[1,0])],[(dotq[0,0]**2)*self.armP.k2*math.sin(q[1,0])]])
    #inversion of M
    Minv = np.linalg.inv(M)
    #torque term
    Q = np.diag([q[0,0], q[0,0], q[1,0], q[1,0], q[0,0], q[0,0]])
    #the commented version uses a non null stiffness for the muscles
    #Gamma = np.dot((np.dot(self.armP.At, self.musclesP.fmax)-np.dot(self.musclesP.Kraid, Q)), U)
    Gamma = np.dot((np.dot(self.armP.At, self.musclesP.fmax)-np.dot(self.musclesP.Knulle, Q)), U)

    #computes the ddotq acceleration and integrates
    ddotq = np.dot(Minv,(Gamma - C - np.dot(self.armP.B, dotq)))
    dotq += ddotq*dt
    q += dotq*dt
    return ddotq, dotq, q

def mgi(xi, yi):
    '''
    Inverse geometric model of the arm
        
    Inputs:     -xi: abscissa of the end-effector point
                -yi: ordinate of the end-effectior point

    Outputs:
                -q1: arm angle
                -q2: foreArm angle
    '''
    a = ((xi**2)+(yi**2)-(self.armP.l1**2)-(self.armP.l2**2))/(2*self.armP.l1*self.armP.l2)
    try:
        q2 = math.acos(a)
        c = self.armP.l1 + self.armP.l2*(math.cos(q2))
        d = self.armP.l2*(math.sin(q2))
        q1 = math.atan2(yi,xi) - math.atan2(d,c)
        return q1, q2
    except ValueError:
        print("forbidden value")
        return "None"
    
    
def mgd(q):
    '''
    Direct geometric model of the arm
        
    Inputs:     -q: (2,1) numpy array
        
    Outputs:
                -coordElbow: elbow coordinate
                -coordHand: hand coordinate
    '''
    coordElbow = (self.armP.l1*np.cos(q[0,0]), self.armP.l1*np.sin(q[0,0]))
    coordHand = (self.armP.l2*np.cos(q[1,0] + q[0,0]) + self.armP.l1*np.cos(q[0,0]), self.armP.l2*np.sin(q[1,0] + q[0,0]) + self.armP.l1*np.sin(q[0,0]))
    return coordElbow, coordHand
    
    
def jointStop(q):
    '''
    Articular stop for the human arm
    Shoulder: -0.6 <= q1 <= 2.6
    Elbow: -0.2 <= q2 <= 3.0
    
    Inputs:    -q: (2,1) numpy array
    
    Outputs:    -q: (2,1) numpy array
    '''
    if q[0,0] < -0.6:
        q[0,0] = -0.6
    elif q[0,0] > 2.6:
        q[0,0] = 2.6
    if q[1,0] < -0.2:
        q[1,0] = -0.2
    elif q[1,0] > 3.0:
        q[1,0] = 3.0
    return q

    
    
    
    
    
    
    
    
