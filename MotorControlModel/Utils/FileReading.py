#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author: Thomas Beucher
Module: FileReading
Description: Functions to read project data
'''

import random as rd
import pickle
import numpy as np
import os
import json

from ArmModel.Arm import Arm

def getobjread(name):
    '''
    Get data from a file
    
    Input: the full name of the file to read
    
    Output: the obtained data
    '''
    with open(name, "rb") as file:
        mondepickler = pickle.Unpickler(file)
        data = mondepickler.load()
    return data

def getobjreadJson(name):
    '''
    Reads data from file saved with json
    '''
    f = open(name, 'r')
    data = json.load(f)
    return data

def getInitPos(location):
    '''
    Cette fonction permet de recuperer toutes les positions initiales des trajectoires utilisees pour
    entrainer l'algorithme de regression
    
    Output : dictionary of initial position of all trajectories
    '''
    print("Debut de recuperation des positions initiales!")
    arm = Arm()
    angleIni = {}
    Q = []
    for el in os.listdir(location):
        if "trajectoire" in el or "brentbvp" in el:
                #Chargement du fichier
            mati = np.loadtxt(location + el)
            Q.append((el, mati[0,10], mati[0,11]))
                #recuperation de q1 et q2 initiales et conversion en coordonnees
            coordElbow, coordHand = arm.mgd(np.mat([[mati[0,10]], [mati[0,11]]]))
            angleIni[el] = (coordHand[0], coordHand[1])
    print("Fin de recuperation des positions initiales!")
    return angleIni, Q
  
def getStateAndCommandDataFromBrent(location):
    '''
    Put all the states and commands of trajectories generated by the Brent controller into 2 different dictionaries
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    -command: dictionary keys = filenames, values = array of data
    '''
    state, command = {}, {}
    for el in os.listdir(location):
        if rd.random()<0.01:
            state[el], command[el] = [], []
            mati = np.loadtxt(location + el)
            for i in range(mati.shape[0]):
                state[el].append((mati[i][8], mati[i][9], mati[i][10], mati[i][11]))
                command[el].append((mati[i][18], mati[i][19], mati[i][20], mati[i][21], mati[i][22], mati[i][23]))
    return state, command

def getStateDataFromBrent(location):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    state = {}
    for el in os.listdir(location):
        state[el] = []
        mati = np.loadtxt(location + el)
        for i in range(mati.shape[0]):
            state[el].append((mati[i][8], mati[i][9], mati[i][10], mati[i][11]))
    return state
    
def dicToArray(data):
        '''
        This function transform a dictionary into an array
        
        Input:     -data: dictionary
        Output:    -dataA: numpy array
        '''
        retour = []
        for k, v in data.items():
            retour.append(v)
        return np.vstack(np.array(retour))
    
            
    


    



