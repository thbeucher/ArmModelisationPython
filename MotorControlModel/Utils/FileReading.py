#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Author: Thomas Beucher
Module: FileReading
Description: Functions to read project data
'''
import random as rd
import pickle
import numpy as np
import os
import json

from ArmModel.Arm import Arm

def getobjread(name):
    '''
    Get data from a file
    
    Input: the full name of the file to read
    
    Output: the obtained data
    '''
    with open(name, "rb") as file:
        mondepickler = pickle.Unpickler(file)
        data = mondepickler.load()
    return data

def getobjreadJson(name):
    '''
    Reads data from file saved with json
    '''
    f = open(name, 'r')
    data = json.load(f)
    return data

def getInitPos(foldername):
    '''
    Cette fonction permet de recuperer toutes les positions initiales des trajectoires utilisees pour
    entrainer l'algorithme de regression
    
    Output : dictionary of initial position of all trajectories
    '''
    print("Debut de recuperation des positions initiales!")
    arm = Arm()
    xy = {}
    for el in os.listdir(foldername):
        #Chargement du fichier
            data = np.loadtxt(foldername + el)
                #recuperation de q1 et q2 initiales et conversion en coordonnees
            coordElbow, coordHand = arm.mgd(np.array([[data[0,10]], [data[0,11]]]))
            xy[el] = (coordHand[0], coordHand[1])
    print("Fin de recuperation des positions initiales!")
    return xy
  
def getStateAndCommandData(foldername):
    '''
    Put all the states and commands of trajectories generated by the Brent controller into 2 different dictionaries
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    -command: dictionary keys = filenames, values = array of data
    '''
    state, command = {}, {}
    for el in os.listdir(foldername):
        #if rd.random()<0.001:
            state[el], command[el] = [], []
            data = np.loadtxt(foldername + el)
            for i in range(data.shape[0]):
                state[el].append((data[i][8], data[i][9], data[i][10], data[i][11]))
                command[el].append((data[i][18], data[i][19], data[i][20], data[i][21], data[i][22], data[i][23]))
    return state, command
  
def getCommandData(foldername):
    '''
    Put all the states and commands of trajectories generated by the Brent controller into 2 different dictionaries
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    -command: dictionary keys = filenames, values = array of data
    '''
    command = {}
    for el in os.listdir(foldername):
            command[el] = []
            data = np.loadtxt(foldername + el)
            for i in range(data.shape[0]):
                command[el].append((data[i][18], data[i][19], data[i][20], data[i][21], data[i][22], data[i][23]))
    return command

def getStateData(foldername):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    state = {}
    for el in os.listdir(foldername):
        state[el] = []
        data = np.loadtxt(foldername + el)
        for i in range(data.shape[0]):
            state[el].append((data[i][8], data[i][9], data[i][10], data[i][11]))
    return state

def getXYHandData(foldername):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    arm = Arm()
    xy = {}
    for el in os.listdir(foldername):
        xy[el] = []
        data = np.loadtxt(foldername + el)
        for i in range(data.shape[0]):
           coordElbow, coordHand = arm.mgd(np.array([[data[i][10]], [data[i][11]]]))
           xy[el].append((coordHand[0], coordHand[1]))
    return xy

def getXYElbowData(foldername):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    arm = Arm()
    xy = {}
    for el in os.listdir(foldername):
        xy[el] = []
        data = np.loadtxt(foldername + el)
        for i in range(data.shape[0]):
           coordElbow, coordHand = arm.mgd(np.array([[data[i][10]], [data[i][11]]]))
           xy[el].append((coordElbow[0], coordElbow[1]))
    return xy

def getEstimatedStateData(foldername):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    state = {}
    for el in os.listdir(foldername):
        state[el] = []
        data = np.loadtxt(foldername + el)
        for i in range(data.shape[0]):
            state[el].append((data[i][4], data[i][5], data[i][6], data[i][7]))
    return state
    
def getEstimatedXYHandData(foldername):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    arm = Arm()
    xy = {}
    for el in os.listdir(foldername):
        xy[el] = []
        data = np.loadtxt(foldername + el)
        for i in range(data.shape[0]):
           coordElbow, coordHand = arm.mgd(np.array([[data[i][6]], [data[i][7]]]))
           xy[el].append((coordHand[0], coordHand[1]))
    return xy
    
def getCostData(foldername):
    '''
    Put all the states of trajectories generated by the Brent controller into a dictionary
    
    Outputs:    -state: dictionary keys = filenames, values = array of data
    '''
    costDico = {}
    for el in os.listdir(foldername):
        costDico[el] = []
        data = np.loadtxt(foldername + el)
        for i in range(data.shape[0]):
           x = data[i][0]
           y = data[i][1]
           cost = data[i][2]
           costDico[el].append((x, y, cost))
    return costDico

def dicToArray(data):
        '''
        This function transform a dictionary into an array
        
        Input:     -data: dictionary
        Output:    -dataA: numpy array
        '''
        retour = []
        for k, v in data.items():
            retour.append(v)
        return np.vstack(np.array(retour))
    
            
    


    



